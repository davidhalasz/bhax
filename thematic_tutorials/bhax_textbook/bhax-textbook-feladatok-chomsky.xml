<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A decimális számrendszer, vagy más néven tízes számrendszer egy 10 elemből álló halmaz, melynek első tagja a 0, az utolsó tagja pedig a 9.
            Ha ezt át szeretnénk váltani unáris, azaz egyes számrendszerbe, akkor a végeredményként egy csupa 1-esekből álló értéket kapunk.
            Az 1 csupán szimbólum, lehet helyettesíteni bármilyen más szimbólummal, a lényeg, hogy az N számot az általunk választott szimbólum 
            N-szeri ismétlésével ábrázoljuk.
        </para>
        <para>
            Ha egy decimálisból unárisba átváltó programot szeretnénk írni, akkor egy olyan ciklust kell létrehozni, ami mindig annyiszor írja ki az egyest, ahány számot adtunk meg. 
            Ha az adott szám nulla, akkor eredményként nem fogunk kapni semmit, mivel a nullát nem képes egyes számrendszerben ábrázolni.
        </para>
         <programlisting language = "c"><![CDATA[
#include <stdio.h>

int main()
{
    int a;
    int count = 0;

    printf("Adj meg egy természetes számot\n");
    scanf("%d", &a);
    printf("A beírt szám unáris alakban:");
	
    for (int i = 0; i < a; ++i) {
        printf("1");
        count++;
    }
	
    printf("\n");
    return 0;
}
 ]]>
        </programlisting>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A Noam Chomsky nevéhez fűződő úgynevezett Chomsky-féle hierarchia 1-es típusa definiálja a környezetfüggő nyelvtanokat.
            Kétféle szabály létezik:
        </para>
        <itemizedlist mark='opencircle'>
            <listitem>
                <para>
                    <function>αAγ → αβγ</function> alakú,
                </para>
                <para>
                    ahol <function>A∈N,α, γ∈(N∪T)∗, β∈(N∪T)+</function>. Tehát itt az <function>A</function> nemterminális, <function>α</function> 
                    pedig egy nemterminálisokból és terminálisokból álló
                    üres vagy nem üres szó. A jobb oldalon álló <function>β</function> és <function>γ</function> viszont már nemterminális és terminálisokból álló szavak.
                </para>
            </listitem>
            <listitem>
                <para>
                    <function>S→ε</function> alakú,
                </para>
                <para>
                    ahol az <function>S</function> kezdőszimbólum nem szerepel egyetlen szabály jobb oldalán sem.
                </para>
                <para>
                    Egy példa: Legyen
                    <function>G=({S, A, B, C}, {a, b, c}, S, {S → λ, S → abc, S → aABC, A → aABC, A → aBC, CB → BC, aB → ab, bB → bb, bC → bc, cC → cc}).</function>
                </para>
                <para>
                    Ekkor bizonyítható, hogy G az <function>L(G)={a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript>|n ≥ 0}</function> nyelvet generálja.
                </para>
            </listitem>
        </itemizedlist>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  https://gitlab.com/davidhalasz/bhax/blob/master/attention_raising/Source/Chomsky/szabvany.c
        </para>
        <para>
            A BNF (Backus-Naur Form) egy olyan metanyelv, menylek segítségével szabályok alkothatók meg. Legfőbb célja a programozási nyelvek szintaxisának leírása.
            Főbb részei:
        </para>
        <itemizedlist mark='opencircle'>
                <listitem>
                    <para>
                     <function> &lt;név&lt; </function>
                    </para>
                    <para>
                      Olyan fogalmak tartoznak ide, mint pl.: azonosító, betű, törtszám, príszám, stb. Tehát bármi lehet. Nem terminális elem.
                    </para>
                </listitem>
                 <listitem>
                    <para>
                     <function> ::= </function>
                    </para>
                    <para>
                      Ez fogja elválasztani a szabály bal- és jobb oldalát.
                    </para>
                </listitem> <listitem>
                    <para>
                     A definiáldandó nyelv karakterkészlete, azaz a terminálisok. Az elválasztó jel jobb oldalán helyezkedik el.
                    </para>
                </listitem>
        </itemizedlist>
        <para>
            Ezek alapján néhány C utasítások BNF-ben:
        </para>
        <programlisting language="algol"><![CDATA[
            //feltételes utasítás
            if (<kifejezés>)
                <utasítás>
            else if (<kifejezés>)
                <utasítás>
            else (<kifejezés>)
                <utasítás>
            
            //while utasítás
            while (<kifejezés>)
                do <utasítás>
           ]]>
        </programlisting>
        <para>
            Most pedig jöjjön egy olyan kódcsipet, amely c89-cel nem, de c99-el működik: 
        </para>
        <programlisting>
            int main()
            {
                //comment
                return 0;
            }
        </programlisting>
        <para>
            A fenti kódot ha c89-cel fordítjuk le, akkor az alábbi hibaüzenetet fogunk kapni:
        </para>
        <programlisting>
            gcc -std=c89 szabvany.c -o szabvany
            
            szabvany.c: In function ‘main’:
            szabvany.c:3:5: error: C++ style comments are not allowed in ISO C90
                 //comment
                 ^
            szabvany.c:3:5: error: (this will be reported only once per input file)
        </programlisting>
        <para>
            Ha pedig c99-cel, akkor gond nélkül működik:
        </para>
        <programlisting>
            gcc -std=c99 szabvany.c -o szabvany
        </programlisting>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Az alábbi kódot .l végződésű fálba kell menteni, mert a lex programmal fogunk dolgozni. 
            A program segítségével lexikális szabályokból lexikális elemző programkódot fogunk generálni.
            Ehhez a következő parancsot kell megadnunk: <function>lex -o lexer.c lexer.l</function>, ami elkészíti számunka a c forráskódot.
            Ezután már csak a szokásos módon gcc-vel fordítjuk le, azzal a különbséggel, hogy a végéhez beírjuk az <function>-lfl</function> is: 
            <function>gcc lexer.c -o lexer -lfl</function>.
            
        </para>
        <programlisting language = "c"><![CDATA[
            %{
                #include <stdio.h>
                    
                int realnumbers = 0;
                %}
                digit	[0-9]
                %%
                {digit}*(\.{digit}+)?	{++realnumbers; 
                    printf("[realnum=%s %f]", yytext, atof(yytext));}
                %%
                int
                main ()
                {
                 yylex ();
                 printf("The number of real numbers is %d\n", realnumbers);
                 return 0;
            }
        ]]>
        </programlisting>
        <para>
            A fenti program 3 fő részből áll, amelyeket a %% szimbólum választja szét őket. Az első rész tartalmazza a headert és a változót. Itt bármilyen C kódot megadhatunk a %{ és %}
            jelek között. Ezt a Flex módosítás nélkül fogja átmásolni a generálandó kódba.
        </para>
        <para>
            A második rész 2 részből álló szabályokat tartalmaz: Először a reguláris kifejezésekkel kezdjük, utána jön a kapcsos zárójelbe zárva a C kód.
            A reguláris kifejezéseknél határozzuk meg a keresési szabályokat. Jelen esetben számmal kezdődőt keresünk (digit), ami akár többször
            is előfordulhat (*). Ezt követően van egy zárójeles rész is, ami azt jelenti, hogy ?????
            Az ezt követő C kódban adjuk meg, hogy majd a terminálba bevitt szöveget vizsgálja meg. Az atof() függvény segítségével a string-ből double lesz. Tehát ezekből a szabályokból létrejön majd a
            yylex nevű függvény és return esetén újra ide fog visszakerülni.
        </para>
        <para>
            A program harmadik részében látható egy <function>yylex()</function> függvény, ami a fenti szabályokat hívja elő, továbbá kiíratjuk az eredményt.
        </para>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            A leet nyelv lényege, hogy bizonyos betűket számokkal vagy ASCII karakterekkel szokták helyettesíteni. Innen jön az,hogy leet helyett l33t írunk.
            A mostani példában olyan programot mutatok be, ami az adott szövegben ezeket a betűket kicseréli a megfelelő számokkal, vagy karakterekkel. A megadott forráskódot is 
            lex programmal kell C-be fordítani. Vizsgáljuk meg a programot. Ahogy az előző feladatnál, úgy itt is 3 részből áll.
        </para>
        <para>
            Az első részben definiáljuk a <function>L33SIZE</function> konstansszerű elemet. Ezt a <function>#define</function> segítségével oldjuk meg és a nevet mindig csupa nagybetűvel
            kell megadni. Ha a programban valahol beírjuk a megadott konstans nevet (L33SIZE), akkor a helyére fogja majd behellyettesíteni a hozzá tartozó szöveget. Jelen esetben ehhez a változóhoz
            meg van adva egy char c és egy hozzá tartozó char *leet[4] tömb, ebből a kettőből fog összeállni a l337d1c7[] tömb, ahol az előbbi lesz majd a kicserélendő betű, utóbbi pedig az, 
            hogy mire lehet majd kicserélni (4 választási lehetőség van).
        </para>
        <programlisting language = "c"><![CDATA[
#define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } l337d1c7 [] = {

  {'a', {"4", "4", "@", "/-\\"}},
    ...
                        
]]>
        </programlisting>
        <para>
            Ha az egyes betűkhöz hozzárendeltük a megfelelő számokat vagy karaktereket. Akkor a második részben fogjuk megadni C-ben, hogy hogyan történjen a karaktercsere:
        </para>
        <programlisting language = "c"><![CDATA[
...
. {
	  
	  int found = 0;
	  for(int i=0; i<L337SIZE; ++i)
	  {
	  
	    if(l337d1c7[i].c == tolower(*yytext)) //Megegyezik-e a két karakter?
	    {
	    
	      int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0)); //random szám generálása 1 és 100 között
	    
          if(r<91)
	        printf("%s", l337d1c7[i].leet[0]);
          else if(r<95)
	        printf("%s", l337d1c7[i].leet[1]);
	      else if(r<98)
	        printf("%s", l337d1c7[i].leet[2]);
	      else 
	        printf("%s", l337d1c7[i].leet[3]);

	      found = 1;
	      break;
	    }
	    
	  }
	  
	  if(!found)
	     printf("%c", *yytext);	  
	  
	}
         
...
]]>
        </programlisting>
        <para>
            A kapcsos zárójel elején egy pont van, ami azt jelenti, hogy minden egyes karaktert vizsgáljon meg a szövegben. Ez lesz tehát a reguláris kifejezés. 
            A C részben látható, hogy a <function>for</function> ciklusban előhívjuk
            a <function>L33SIZE</function> nevű konstanst, tehát ide fogja behellyettesíteni azt, amit már az első részben megadtunk.
        </para>
        <para>
            Szükségünk lesz a <function>tolower()</function> függvényre is, mert ha nagybetű van a szövegben, akkor azt nem fogja számításba venni a program, ezért ezzel a fügvénnyel minden
            betűt kisbetűvé alakítunk át. Ezután a kapott random szám alapján cseréljük ki az adott betűket. Tehát például az "a" betűt kell kicserélni, és <function>r</function> értéke 
            97, akkor ez azt jelenti, hogy az "a" betű "@"-ra lesz kicserélve, mivel az if-else utasításban itt fog teljesülni: 
        </para>
         <programlisting language = "c"><![CDATA[
...
    else if(r<98)
	printf("%s", l337d1c7[i].leet[2]);
...
           
]]>
        </programlisting>
        <para>
            Ez azt jelenti, hogy l337d1c7[i] tömbön belül a leet[2] tömb 3. eleme legyen kiválasztva, ami a "@". Előfordul azonban, hogy a két karakter nem egyezik meg a vizsgálat során (<function>if(!found)</function>, ezért 
            ilyenkor az eredeti karakert íratjuk ki.
        </para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            </listitem>
        </orderedlist>
        <para>
            Megoldás forrása:  
        </para>

        <para>
            Megoldás videó: 
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>            
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>            
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
