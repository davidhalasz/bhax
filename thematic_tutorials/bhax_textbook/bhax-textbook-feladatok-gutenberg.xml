<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>
        </para>
        <para>
            1. ALAPFOGALMAK
A programozási nyelveknek három szintjét különböztethetjük meg: gépi nyelv, assembly szintű nyelv és magas szintű nyelv. 
A magas szintű nyelven megírt programot forrásprogramnak nevezzük. Ezek összeállítására vonatkozó formai szabályok összességét pedig szintaktikai szabályoknak. A tartalmi, értelmezési, jelentésbeli szabályok alkotják a szemantikai szabályokat. Ez a két szabály együttese határozza meg a magas szintű programozási nyelvet.
Ahhoz, hogy az adott processzor végre tudja hajtani a programokat, szükség lesz fordító programokra vagy interpreterre, amik lefordítják a processzor saját gépi kódú nyelvére. 
Az a különbség a fordítóprogramok és az interpreterek között, hogy az utóbbi nem készít tárgyprogramot, hanem utasításonként értelmezi a forrásprogramot és rögtön végre is hajtja azokat. Egyébként mindkét program végez lexikális (forrásszöveg feldarabolása lexikális egységekre), szintaktikai (Teljesülnek-e az adott nyelv szintaktikai szabályai?) és szemantikai  elemzés. Ahhoz, hogy egy programot helyesen írjunk meg, át kell tanulmányozni az adott programnyelvek szabványait (hivatkozási nyelv). A legnagyobb probléma a programozási nyelvekkel kapcsolatban, az a hordozhatóság, ami az egyik magas szintű programnyelvből egy másik programnyelvre történő implementációja, ugyanis ez a technika jelenleg nem megoldott.
A programnyelvek osztályozása háromféleképpen történik: imperativ nyelvek, deklaratív nyelvek és máselvű (egyéb) nyelvek. Az imperatív nyelvekhez tartoznak az algoritmikus nyelvek, a program utasítások sorozata. Legfőbb programozói eszköz a változó, amihez értékeket rendelhetünk, manipulálhatjuk az adatokat, tehát a tár közvetlen elérése. Ez a nyelv szorosan kötődik a Neumann-architektúrához. Két alcsoportja van: Eljárásorientált- és objektumorientált nyelvek. Ezzel szemben a deklaratív nyelvek nem algoritmikus nyelvek, nem kötődnek szorosan a Neumann architektúrához. A programozó csak a problémát adja meg, és nincs lehetősége memóriaműveletekre. Alcsoportjai a funkcionális- és logikai nyelvek. A másnyelvű(egyéb) nyelvekhez pedig azok tartoznak, amiket nem lehet besorolni a fenti két nyelvek valamelyikébe.
        </para>
        <para>
2. Adattípusok
</para>
<para>
Az adattípus a programozási nyelvekben egy absztrakt programozási eszköz. A típuslétrehozás úgy történik, hogy megadjuk a tartományát, a műveleteit és a reprezentációját. Vannak esetek, amikor a saját típust a beépített és a már korábban definiált saját típusok segítségével adjuk meg. Nem minden programozási nyelv ismeri ezt az eszközt, ezért ennek megfelelően elkülöníthetünk típusos és nem típusos nyelveket. Egy adattípus három dolgot határoz meg: tartomány, műveletek, reprezentáció. A tartomány tartalmazza azokat az elemeket, amelyeket az adott programozási eszköz felvehet értékként. Egyszerű típus lehet például a C nyelvben int típus, ami az egész számokra vonatkozik. Ott van továbbá a char, azaz a karakteres típus, amelynek elemei karakterek. De létezik még logikai, felsorolásos, sorszámozott típus stb. 
Az összetett típushoz tartoznak például a tömbök, amik lehetnek statikus vagy homogén összetett típus. attól függően, hogy a tömb elemeiben milyen típusú értékek fordulnak elő. Továbbá ide tartozik még a rekord típusú programozási eszköz is.
Fontos még a mutató típus, amelyek tartományának elemei lényegében tárcímek, tehát az adott eszköz a tár adott területét címzi.
A nevesített konstans olyan programozási eszköz, amelynek három komponense van: név, típus, érték. A C programban a nevesített konstanst így kell elképzelni: #define név literál. Lényege, hogy előre definiáljuk a konstansok értékeit és a programban bárhol hivatkozhatunk rá a konstans nevének használatával, így betöltjük az ott lévő adatokat. Továbbá, ha meg akarjuk változtatni az adatot, akkor elég csak a deklarációs részben megváltoztatni, így az egész programban érvényes lesz a megváltoztatott érték.
A változónak négy komponense van: név, attribútumok, cím, érték. A név egy azonosító, ahogy a nevesített konstansoknál is van. Az attribútumok pedig a változók futás közbeni viselkedését határozzák meg, például ha típust rendelünk hozzá (int, char stb). A cím a tárnak azt a részét határozza meg, ahol a változó értéke elhelyezkedik. Az értéket a típussal összhangban kell megadni.
A C nyelv típusrendszere lehet artimetikai és származtatott típusok. Az artimetikai típusok tartományának elemeivel artimetikai műveletek végezhetők:
</para>
<para>
    <itemizedlist mark='opencircle'>
                <listitem>
                    <para>
                        egész típus: int szam = 5
                    </para>
                </listitem>
                <listitem>
                    <para>
                        karakter típus: char szoveg = ’valami’
                    </para>
                </listitem>
                <listitem>
                    <para>
                        felsorolás: enum szinek {VOROS=11, NARANCS=9, SARGA=7, ZOLD=5, KEK=3, IBOLYA=3};
                    </para>
                </listitem>
                 <listitem>
                    <para>
                        valós (float, double, long double)
                    </para>
                </listitem>
    </itemizedlist>
</para>
<para>
    Származtatott típusok lehetnek:
</para>
<para>
    <itemizedlist mark='opencircle'>
                 <listitem>
                    <para>
                        tömb: int tomb[5]  
                    </para>
                </listitem>
                 <listitem>
                    <para>
                        mutató: int *mut
                    </para>
                </listitem>
                 <listitem>
                    <para>
                        függvény: fgv()
                    </para>
                </listitem>
                <listitem>
                    <para>
                        struktúra: STRUCT [struktúratípus_név] {mezı_deklarációk} [változólista];
                    </para>
                </listitem>
                <listitem>
                    <para>
                        union: UNION [uniontípus_név] {mezı_deklarációk} [változólista];
                    </para>
                </listitem>
    </itemizedlist>
</para>
<para>
    3. Kifejezések
</para>
<para>
    A kifejezések szintaktikai eszközök. Lényege, hogy ha a programban már ismert értékek segítségével új értékeket határozunk meg. Formálisan operandusokból, operátorokból és kerek zárójelekből állnak. A kifejezésnek három alakja lehet: pre-, in- és postfix. A prefix esetében az operátor az operandusok előtt áll (* 3 5). Infix-nél az operátor középen(3 * 5). Postfix-nél pedig az operandusok mögött áll az operátor (3 5 *).  
 A C egy kifejezésorientált nyelv. Itt a kifejezéseket rekurzívan építjük fel, tehát a kifejezések egyszerű kifejezésekből épülnek fel, zárójelek és operátorok használatával, majd ezt az egészet lexikális egységek zárják le. Az artimetikai típusoknál a típuskényszerítés elvét vallja, ami azt jelenti, hogy egy két operandusú operátornak különböző típusú operandusai lehetnek, de a műveletek csak azonos típusok között végezhetők el. Bizonyos esetekben konverzió van, tehát a nyelv megvizsgálja, hogy milyen típuskombinációk megengedettek.
</para>
<para>
    4. Utasítások
</para>
<para>
    Az utasítások olyan program egységek, amelyekkel megadhatjuk az algoritmusok egyes lépéseit, továbbá a fordítóprogramok ezek segítségével generálja a tárgykódot. Két csoportból áll: deklarációs és végrehajtható utasítás.
A deklarációs utasításnál nincs tárgykód, nem kerülnek lefordításra. Ez csak a fordítóprogramoktól kérnek valamilyen szolgáltatás, vagy olyan információkat ad át a fordítóprogramnak, amik szükségesek a tárgykód generálásánál. 
A végrehajtó utasításokból készül el a tárgykód a fordítóprogram által. Ezek tovább csoportosíthatók: 
</para>
<para>
    <itemizedlist mark='opencircle'>
                 <listitem>
                    <para>
                        értékadó utasítás: változó értékének beállítása a program futása során. 
                    </para>
                </listitem>
                 <listitem>
                    <para>
                        üres utasítás: üres gépi utasítás 
                    </para>
                </listitem>
                 <listitem>
                    <para>
                        ugró utasítás: feltétel nélküli vezérlés átadó utasítás során egy adott címkével ellátott végrehajtható utasításra adhatjuk át a vezérlést. Használt alakja: GOTO címke
                    </para>
                </listitem>
                <listitem>
                    <para>
                       elágaztató utasítás: 
                    </para>
                    <para>
                        Kétirányú elágaztató utasítás: ebben az esetben a program két tevékenység közül választ és a választott tevékenységet végrehajtja (vagy ellenkezőleg). A feltételes utasítás alakja: <function>IF feltétel THEN tevékenység [ ELSE tevékenység ]</function>
                        Ha nem szerepel az ELSE-ág, akkor hosszú alakról van szó, ellenkező esetben rövid utasítás. Működése úgy zajlik, hogy előbb kiértékelődik a feltétel. Ha ez igaz, akkor az ott lévő tevékenység végrehajtódik. Ha a feltétel hamis és van else ág, akkor az ott lévő feltétel is kiértékelődik. Szót kell még ejteni a „csellengő ELSE” problémáról is, ami akkor fordul elő, amikor egy rövid if utasításba be van ágyazva egy hosszú if utasítás is:
                    </para>
                    <screen>
                        IF … THEN
                            IF … THEN
                            ELSE …
                    </screen>
                    <para>
                        A kérdés az, hogy vajon melyik IF feltételhez tartozik az ELSE-ág? A probléma egyszerűen kiküszöbölhető, ha egy hosszú utasításba ágyazzuk be a hosszú utasítást, úgy hogy a külső ELSE-ágba üres utasítás szerepel. De némely programnál nincs szükség erre, ugyanis az implementáció többsége azt mondja, hogy az értelmezés belülről kifelé történik, tehát minden egyes ELSE-ágat belülről kifelé párosítjuk az adott IF utasításokhoz.   
                    </para>
                    <para>
                        Többirányú elágaztató utasítás:  Itt a program egymást kölcsönösen kizáró akárhány tevékenység közül egyet választ. C esetében úgy néz ki a dolog, hogy először kiértékelődik a kifejezés, ami egy integer típusú számnak kell lennie.  Ez összehasonlításra kerül a CASE ágak értékeivel. Ha van egyezés akkor az adott ponton végrehajtódik a tevékenység. Ha nincs egyezés, akkor a DEFAULT ággal lépünk ki:
                    </para>
                    <screen>
                    SWITCH (kifejezés) { 
                        CASE egész_konstans_kifejezés : [ tevékenység ] 
                        [ CASE egész_konstans_kifejezés : [tevékenység ]]… 
                        [ DEFAULT: tevékenység ] 
                    };
                    </screen>
                </listitem>
                <listitem>
                    <para>
                    ciklusszervező utasítás: Ez az utasítás lehetővé teszi, hogy egy bizonyos tevékenységet akárhányszor megismételjünk. Felépítése: fej, mag, vég.
                    Működés szerint 2 típusa van: az egyik az üres ciklus, amikor a a mag egyszer sem fut le, a másik pedig a végtelen ciklus, amikor az ismétlődés soha nem  áll le.
                        Kezdőfeltételes ciklus esetében a feltétel a fejben jelenik meg. Tehát Először kiértékelődik a feltétel, Ha igaz, végrehajtódik a ciklusmag, majd újra kiértékelődik a feltétel egészen addig, amíg hamis nem lesz. Ilyen a WHILE(feltétel) végrehajtható_utasítás. 
                        Végfeltételes ciklus esetében a feltétel a végben van, de vannak nyelvek amelyekben a fej tartalmazza azt. Tehát először végrehajtódik a mag és csak utána vizsgálja meg a feltételt.<function> DO végrehajtható_utasítás WHILE(feltétel);</function>
                        Előírt lépésszámú ciklus: Itt a fejben van a feltétel. Tartalmaz egy változót (ciklusváltozó) és a változó által felvett értékekre fut le a ciklus. <function>FOR([kifejezés1]; [kifejezés2]; [kifejezés3]) végrehajtható_utasítás</function>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        hívó utasítás
                    </para>
                </listitem>
                <listitem>
                    <para>
                        vezérlésátadó utasítás
                    </para>
                </listitem>
                <listitem>
                    <para>
                        I/O utasítás
                    </para>
                </listitem>
                <listitem>
                    <para>
                        egyéb utasítások
                    </para>
                </listitem>
    </itemizedlist>
</para>
<para>
    5. Programok szerkezete
</para>
<para>
    Az alprogramok olyan programozási eszközök, amelyeket akkor használunk ha egy programon belül ugyanaz a programrész többször megismétlődik, így nem kell minden esetben újra megírni a programot, hanem elég csak hivatkoznunk az adott alprogramra. A formális alprogram felépítése a következő: fej vagy specifikáció, törzs vagy implementáció és  vég. Ez a programozási eszköz négy komponensből áll: név, formális paraméter lista, törzs, környezet. 
A név lesz az azonosító, tehát mindig ennek használatával tudunk majd hivatkozni. A formális paraméter listában azonosítók szerepelnek, melyek aktuális értékei a hívás helyén szerepelnek. A formális paraméter lista általában a név mellett zárójelben szerepel. Dönthetünk úgy is, hogy nem adunk meg paramétert, mert az adott alprogramnak nincs szüksége rá. Ekkor ez egy paraméter nélküli alprogram lesz. Ez a két komponens az alprogramban mindig a fejben szerepelnek. A törzsben deklarációs ás végrehajtható utasításokat adunk meg. Az alprogram környezete a globális változók együttese. Globális nevek alatt azt értjük, hogy az alprogramon kívül neveket deklaráltunk, amik elérhetőek az alprogam számára. Van ugyanis lokális nevek is, amik csak az alprogramban érhető el és a külső környezet számára el van rejtve.
Az alprogramnak két típusa van: eljárás és függvény. Az eljárás általában a paraméterek vagy a környezetének megváltoztatását, vagy a törzsben elhelyezett utasítások végrehajtását jelenti. Egy eljárás akkor nevezhető szabályosnak, ha a program futtatása közben elérjük a végét és külön utasítással befejeztetjük. Míg a függvények általában valamilyen értéket adnak vissza. Egy függvényt meghívni csak kifejezésben lehet, ennek alakja: <function>függvénynév(aktuális_paraméter_lista)</function>.
A blokk egy olyan programegység, amely csak egy másik programegységben helyezkedhet el, tehát külső szinten nem. Ezt a programegységet csak az eljárásorientált nyelvek egy része ismeri. Szerepe a nevek hatáskörének elhatárolása.  A blokknak nincs paramétere, de lehetnek a törzsében végrehajtható vagy deklarációs utasítások és úgy lehet elkezdeni, hogy szekvenciálisan kerül rá a vezetés vagy egy GOTO-utasítással ráugrunk a kezdetére.
</para>
<para>
    6. Paraméterek
</para>

<para>
    Paraméterkiértékelés során először mindig a formális paraméter lista lesz az elsődleges, majd ezután rendeljük hozzá az aktuális paramétereket. Annak módszerét, hogy melyik formális paraméterhez, melyik aktuális paraméter fog tartozni, megkülönböztethetjük sorrendi kötés vagy név szerinti kötés szerint.
Sorrendi kötésnél, mint ahogy a nevében is benn van, felsorolás sorrendjében rendelődnek hozzá. A név szerinti kötésnél pedig, az aktuális paraméter listában megadjuk a formális paraméter lista nevét és mellette pedig valamilyen szintaktikával az aktuális paramétert.
A paraméter átadás is különböző módon történhet (érték-, cím-, eredmény-, érték-eredmény-, név-, szöveg szerint). Érték szerinti paraméterátadás       
        </para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>        
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
            A C és C++ nyelv közötti különbségek
        </para>
        <para>
            Ha egy függvénynek nem adunk meg paramétert, akkor tetszőleges számú paraméterrel hívhatjuk meg.  A C++ nyelvben meg kell adnunk a void-ot, 
            aminek jelentése pontosan az, hogy nincs a függvénynek paramétere:
            <programlisting language="c">
            // C üres paraméter
            void f() {
                //az F függvény törzse
            }  

            //C++ üres paraméter
            void f(...) {
                //Az f függvény törzse
            }
            </programlisting>
        </para>
        <para>
            A függvénynevek azonosítása is eltérően működik a két nyelvben. Amíg a C-nél maga a neve az azonosítója, így nem lehet két azonos nevű függvény, addig
            a C++ nyelvben a függvényeket a nevük és argumentumlistájuk együttesen azonosítja, így fordulhatnak elő azonos nevű függvények. A fordító ezt úgy oldja meg, hogy
            a függvényneveket kiegészíti a az argumentumtípus elő- vagy utótagjával, így a linker szintjén különböző nevekkel jelennek meg. Ezt nevezzük névelferdítésnek. 
            Ahhoz, hogy a C és a C++ közötti együttműködés, emiatt ne legyen problémás, használnunk kell az <function>extern "C"</function> deklarációt. Ez lehetővé teszi, hogy a már C fordtóval lefordított függvényeket felhasználhassuk a C++ programunkban is.
            <programlisting language="c">
            //Példa C++ nyelvben azonos azonosítónevű, de eltérő argumentumú függvények
            void PrintTime(int hour, int minute) {
            ...
            }

            int PrintTime(int hour, int minute) {
            ...
            }
            </programlisting>
        </para>
        <para>
            C++ nyelvben van lehetőség alapértelmezett értékeket megadni a függvények argumentumában. Szerepe az, hogy függvényhívásnál megfelelő elemszámú/típusú paramétereket
            adjunk át. Fontos különbség még, hogy a C++ nyelvben van referenciatípus szerinti paraméterátadás is. Ez feleslegessé teszi a pointereket a cím szerinti paraméterátadásnál:
            <programlisting language="c">
            void f(int&amp; i) {
                i = i + 2;
            }

            int main(void) {
                int a = 0;
                f(a);
                print("%\n", a);
            }
            </programlisting>
        </para>
                    <para>
                A fenti programban látható, hogy a referencianeve elé egy &amp; jellel deklaráltuk a referenciát.
            </para>
    </section>        
</chapter>                
