<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/davidhalasz/bhax/tree/master/attention_raising/Source/conway/Myrmecologist">https://gitlab.com/davidhalasz/bhax/tree/master/attention_raising/Source/conway/Myrmecologist</link>               
        </para>
        <para>
            Ebben a fejezetben a hangyaszimulációs programot mutatom be. A program 6 fájlból áll. Az <function>ant.h</function> fájlban deklaráljuk a hangya felépítéséhez kapcsolódó változókat. Az <function>antwin.h</function> fájlban az <function>Antwin()</function> függvényvben is szintén változókat deklarálunk és értékeket adunk meg. Itt az ablakkal és a hangyákkal kapcsolatos adatok vannak megadva(pl ablak szélesség, magasság, hangyák száma, stb.). A <function>closeEvent()</function> az ablakeseményeket figyeli. Ha bezárjuk az ablakot, akkor meghívja a <function>finish()</function> függvényt, ahol a futtatás átvált false értékre. 
            A <function>keyPressedEvent()</function> függvény pedig a billentyűzet leütéseket figyeli. Jelen esetben azt mondjuk, hogyha az user által leütött billentyűzet azonos a P gombbal (<function>event->key() == Qt::Key_P</function>), akkor megállítjuk a programot. Ha a Q billentyűt vagy az esc-t nyomjuk le, akkor kilép a proglamból (<function>close()</function>).
        </para>
        <programlisting language="c++"><![CDATA[
#ifndef ANTWIN_H
#define ANTWIN_H

#include <QMainWindow>
#include <QPainter>
#include <QString>
#include <QCloseEvent>
#include "antthread.h"
#include "ant.h"

class AntWin : public QMainWindow
{
    Q_OBJECT

public:
    AntWin(int width = 100, int height = 75,
           int delay = 120, int numAnts = 100,
           int pheromone = 10, int nbhPheromon = 3,
           int evaporation = 2, int cellDef = 1,
           int min = 2, int max = 50,
           int cellAntMax = 4, QWidget *parent = 0);

    AntThread* antThread;

    void closeEvent ( QCloseEvent *event ) {

        antThread->finish();
        antThread->wait();
        event->accept();
    }

    void keyPressEvent ( QKeyEvent *event )
    {

        if ( event->key() == Qt::Key_P ) {
            antThread->pause();
        } else if ( event->key() == Qt::Key_Q
                    ||  event->key() == Qt::Key_Escape ) {
            close();
        }

    }

    virtual ~AntWin();
    void paintEvent(QPaintEvent*);

private:

    int ***grids;
    int **grid;
    int gridIdx;
    int cellWidth;
    int cellHeight;
    int width;
    int height;
    int max;
    int min;
    Ants* ants;

public slots :
    void step ( const int &);

};

#endif
            ]]>
        </programlisting>
        <para>
            Az <function>antwin.cpp</function> fájlon belül a <function>setWindowTitle()</function> segítségével adunk nevet az ablaknak, ami a program elindítása után a fejlécben fog majd megjelenni.
            Az ablak méretét a header fájlból kérjük le. Ezután for ciklussal létrehozunk két négyzetrácsot, ezek egy <function>grids</function> nevű tömbben lesznek eltárolva. Az <function>ants</function> változó meghívja az Ants() függvényt, azaz létrehozzuk a hangyákat. Az <function>antThread</function> pedig a fenti adatok alapján létrehozza az egész életteret. 
        </para>
        <programlisting language="c++"><![CDATA[
#include "antwin.h"
#include <QDebug>

AntWin::AntWin ( int width, int height, int delay, int numAnts,
                 int pheromone, int nbhPheromon, int evaporation, int cellDef,
                 int min, int max, int cellAntMax, QWidget *parent ) : QMainWindow ( parent )
{
    setWindowTitle ( "Ant Simulation" );

    this->width = width;
    this->height = height;
    this->max = max;
    this->min = min;

    cellWidth = 6;
    cellHeight = 6;

    setFixedSize ( QSize ( width*cellWidth, height*cellHeight ) );

    grids = new int**[2];
    grids[0] = new int*[height];
    for ( int i=0; i<height; ++i ) {
        grids[0][i] = new int [width];
    }
    grids[1] = new int*[height];
    for ( int i=0; i<height; ++i ) {
        grids[1][i] = new int [width];
    }

    gridIdx = 0;
    grid = grids[gridIdx];

    for ( int i=0; i<height; ++i )
        for ( int j=0; j<width; ++j ) {
            grid[i][j] = cellDef;
        }

    ants = new Ants();

    antThread = new AntThread ( ants, grids, width, height, delay, numAnts, pheromone,
                                nbhPheromon, evaporation, min, max, cellAntMax);

    connect ( antThread, SIGNAL ( step ( int) ),
              this, SLOT ( step ( int) ) );

    antThread->start();

}
            ]]>
        </programlisting> 
        <para>
            A <function>paintEvent</function> függvénnyel történik a színezés, ami a hangyákat fogja szimbolizálni. Először is for ciklussal végigmegyünk a sorokon és az oszlopokon és azt mondjuk hogy a hangyákat szimuláló kis téglalapokat (<function>fillRect</function>) színezzük be.
        </para>
        <programlisting language="c++"><![CDATA[
void AntWin::paintEvent ( QPaintEvent* )
{
    QPainter qpainter ( this );

    grid = grids[gridIdx];

    for ( int i=0; i<height; ++i ) {
        for ( int j=0; j<width; ++j ) {

            double rel = 255.0/max;

            qpainter.fillRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight,
                                QColor ( 255 - grid[i][j]*rel,
                                         255,
                                         255 - grid[i][j]*rel) );

            if ( grid[i][j] != min )
            {
                qpainter.setPen (
                    QPen (
                        QColor ( 255 - grid[i][j]*rel,
                                 255 - grid[i][j]*rel, 255),
                        1 )
                );

                qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                    cellWidth, cellHeight );
            }



            qpainter.setPen (
                QPen (
                    QColor (0,0,0 ),
                    1 )
            );

            qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight );

        }
    }

    for ( auto h: *ants) {
        qpainter.setPen ( QPen ( Qt::black, 1 ) );

        qpainter.drawRect ( h.x*cellWidth+1, h.y*cellHeight+1,
                            cellWidth-2, cellHeight-2 );

    }

    qpainter.end();
}

AntWin::~AntWin()
{
    delete antThread;

    for ( int i=0; i<height; ++i ) {
        delete[] grids[0][i];
        delete[] grids[1][i];
    }

    delete[] grids[0];
    delete[] grids[1];
    delete[] grids;

    delete ants;
}

void AntWin::step ( const int &gridIdx )
{

    this->gridIdx = gridIdx;
    update();
}
            ]]>
        </programlisting>
        <para>
            Az <function>antthread.cpp</function>-n belül történik a hangyák kiíratása és mozgatása. 
            Ahhoz, hogy a hangyák mozgása véletlenszerűen történjen, a <function>qsrand()</function> függvényt hívjuksegítségül, ahol paraméterként a másodpercenként változó időt adjuk meg.
        </para>
        <programlisting language="c++"><![CDATA[
#include "antthread.h"
#include <QDebug>
#include <cmath>
#include <QDateTime>

AntThread::AntThread ( Ants* ants, int*** grids,
                     int width, int height,
                     int delay, int numAnts, 
                     int pheromone, int nbrPheromone, 
                     int evaporation,
                     int min, int max, int cellAntMax)
{
    this->ants = ants;
    this->grids = grids;
    this->width = width;
    this->height = height;
    this->delay = delay;
    this->pheromone = pheromone;
    this->evaporation = evaporation;
    this->min = min;
    this->max = max;
    this->cellAntMax = cellAntMax;
    this->nbrPheromone = nbrPheromone;

    numAntsinCells = new int*[height];
    for ( int i=0; i<height; ++i ) {
        numAntsinCells[i] = new int [width];
    }

    for ( int i=0; i<height; ++i )
        for ( int j=0; j<width; ++j ) {
            numAntsinCells[i][j] = 0;
        }

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    Ant h {0, 0};
    for ( int i {0}; i<numAnts; ++i ) {

        h.y = height/2 + qrand() % 40-20;
        h.x = width/2 + qrand() % 40-20;

        ++numAntsinCells[h.y][h.x];

        ants->push_back ( h );

    }

    gridIdx = 0;
}

            ]]>
        </programlisting>           
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/davidhalasz/bhax/blob/master/attention_raising/Source/conway/java/Sejtautomata.java">https://gitlab.com/davidhalasz/bhax/blob/master/attention_raising/Source/conway/java/Sejtautomata.java</link>               
        </para>
        <para>
           John Horton Conway a 70-es évek elején valósította meg az általa elnevezett Élejtájékot, melynek lényege, hogy
           van egy négyzethálós élettér, és minden cellában egy sejt élhet. Minden sejtnek 8 szomszédja lehet: négy keresztben, négy pedig átlósan.
           A szabályok pedig a következők:
        </para>
        <itemizedlist mark='opencircle'>
            <listitem>
                <para>
                    Ha egy sejtnek kettő vagy három szomszédja van: életben marad.
                </para>
            </listitem>
            <listitem override='bullet'>
                <para>
                    Ha egy sejtnek négy vagy több szomszédja van: meghal. Ugyanez vonatkozik a 2-nél kisebb szomszéddal rendelkezőkre.
                </para>
            </listitem>
            <listitem>
                <para>
                    Ha egy üres cellának pontosan három élő sejt van a szomszédjában, akkor ott új sejt születik.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Innen az élet elnevezeés, ugyanis a szimuláció generációról generációra mutatja meg a sejtek alakulását. Hogy könnyebb legyen elképzelni a fenti szabályokat, készítettem egy ábrát, ami egy lépést (azaz egy generáció születését) mutat be. Az alábbi ábrán a fekete háttérrel rendelkezők az élő sejtek, a piros szegéllyel
            jelöltek jelentik a halálozást, mivel 2-nél kisebb és 3-nál több szomszéddal rendelkeznek. Ezek a következő generációban tehát fehér hátterűek lesznek. Vannak még továbbá üres cellák, zöld szegéllyel, ezeknek
            pontosan 3 élő sejttel rendelkező szomszédjuk van, így a következő lépésben itt fognak új sejtek születeni.  
        </para>
        <mediaobject>
              <imageobject>
                <imagedata fileref="img/conwaymagy.png" width="100%" format="PNG"/>
              </imageobject>
        </mediaobject>
        <para>
            Ezt a szimulációt fogjuk megvalósítani java-ban, melynek neve <function>Sejtautomata.java</function>.
            Először is létrehozzuk a <function>Sejtautomata</function> osztályt, majd azon belül deklaráljuk a változókat és értékeket rendelünk hozzá. Például megadunk két boolean típusú változót, mellyel azt fogjuk meghatározni,
            hogy egy sejt élő vagy halott lesz-e. Továbbá a rács elkészítéséhez fontos adatokat is itt deklaráljuk.
        </para>
        <programlisting language="java"><![CDATA[
public class Sejtautomata extends java.awt.Frame implements Runnable {
    
    public static final boolean ÉLŐ = true;
    public static final boolean HALOTT = false;
    protected boolean [][][] rácsok = new boolean [2][][];
    protected boolean [][] rács;
    protected int rácsIndex = 0;
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;
    protected int szélesség = 20;
    protected int magasság = 10;
    protected int várakozás = 1000;
    private java.awt.Robot robot;
    private boolean pillanatfelvétel = false;
    private static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy <code>Sejtautomata</code> objektumot.
     *
     * @param      szélesség    a sejttér szélessége.
     * @param      magasság     a sejttér szélessége.
     */

     ...
            ]]>
        </programlisting>  
        <para>
            Ezután létrehozzuk a <function>Sejtautomata()</function> függvényt. Itt készítjük el a rácsokat a fenti adatok felhasználásával. Kezdetben a rács minden cellája halott lesz, ezért for ciklussal végigmegyünk először az egyes cellákon és <function>HALOTT</function> azaz false értékeket rendelünk hozzá.
            Meghívjuk a siklóKilövő() függvényt, melynek paraméterként a rácsot, a sor és az oszlop számát adjuk át.
            Lényege, hogy a sejttérbe ezzel helyezzük el a "sikló ágyút". Ez fog majd először megjelenni a programunk elindítása után, mely egy adott irányba fog elindulni. 
            Az <function>addWindowListener</function> függvény figyeli az ablakot, ha bezárjuk, akkor <function>windowClosing</function> függvény leállítja a programot is. Van még egy <function>addKeyListener</function> függvényünk is, amely a nevéből adódóan a billentyűzetleütéseket figyeli. Itt megadjuk hogy, hogy ha a leütött billentyűzet megegyezik a programban megadottakkal, akkor végezze ez az utasításokat. Például 'K' leütése megfelezi a sejtek méretét, 'N' billentyű lenyomásával pedig növeljük. Az 'S' billenytű pillanatfelvételt készít. Itt azért van felkiáltójel a pillanatfelvétel mögött, mert alapértelmezettként false van megadva, ezért 
            ezzel true értékké alakítjuk át. A 'G' billentyűzettel megfelezzük az időt, azaz gyorsítjuk, végül pedig az 'L'-el fogjuk tudni lassítani, ha arra lenne szükségünk.
        </para>
        <programlisting language="java"><![CDATA[
... 

    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        
        siklóKilövő(rács, 5, 60);
        
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
       
        addKeyListener(new java.awt.event.KeyAdapter() {
           
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                   
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                   
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });
       
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });

        cellaSzélesség = 10;
        cellaMagasság = 10;
        try {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }
        setTitle("Sejtautomata");
        setResizable(false);
        setSize(szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        setVisible(true);

        new Thread(this).start();
    }
...
        ]]>
        </programlisting>
        <para>
            Valahogy ki kellene rajzolni az élő sejteket is, ezért készítünk egy <function>paint()</function> függvényt. For ciklussal végigmenyünk a sorokon és az oszlopokon, ha az adott sor adott oszlopában van egy ÉLŐ sejt, akkor feketére színezzük, különben fehér lesz. Továbbá itt figyeljük azt is, hogy a pillanatfelvétel készítés aktiválva lett-e, ha igen, meghívjuk a pillanatfelvétel függvényt és készítünk egy képet továbbá visszaállítjuk false értékre, különben folyamatosan készítené a képeket, amit ugye nem szeretnénk, hogy megtörténjen.
        </para>
        <programlisting language="java"><![CDATA[
... 

 public void paint(java.awt.Graphics g) {
       
        boolean [][] rács = rácsok[rácsIndex];
        
        for(int i=0; i<rács.length; ++i) { 
            for(int j=0; j<rács[0].length; ++j) { 
                
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }
       
        if(pillanatfelvétel) {

            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }
...
        ]]>
        </programlisting> 
        <para>
            A <function>szomszédokSzáma()</function> függvényben fogjuk megszámolni a szomszédokat az adott élő sejt körül. Itt is két for ciklus lesz, a sorok és az oszlopok miatt, azonban -1-től 1-ig fogjuk megvizsgálni, és csak akkor ha aza adott sejt nincs benne (i==0 és j==0). 
        </para>
        <programlisting language="java"><![CDATA[
... 

public int szomszédokSzáma(boolean [][] rács,
    int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
                
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                if(!((i==0) && (j==0))) {
            
                int o = oszlop + j;
                if(o < 0)
                o = szélesség-1;
                else if(o >= szélesség)
                
                o = 0;                
                int s = sor + i;
                if(s < 0)
                    s = magasság-1;
                else if(s >= magasság)
                    s = 0;   

                if(rács[s][o] == állapot)
                    ++állapotúSzomszéd;
            }
        return állapotúSzomszéd;
}
...
        ]]>
        </programlisting> 
        <para>
            A  bevezetőben ismertetett életjáték szabályokat az <function>időFejlődés()</function>-ben adjuk meg.
            If függvénnyel megvizsgáljuk, hogy az adott cella ÉLŐ-e? Ha igen, akkor a vizsgált élő cellának van-e 2 vagy 3 ÉLŐ szomszédja, ha ez teljesül, akkor az ezt követő rácsban is élő marad az adott pozícióban. Ellenkező esetben halott lesz. Ha a vizsgált cella nem élő akkor lépünk az else ágba. If függvénnyel itt azt vizsgáljuk meg, hogy van e pontosan 3 szomszédja, ha igen, akkor ez is élő lesz, ellenkező esetben halott. 
        </para>
        <programlisting language="java"><![CDATA[
... 

public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) { // sorok
            for(int j=0; j<rácsElőtte[0].length; ++j) { // oszlopok
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {
                /* Élő élő marad, ha kettő vagy három élő
                 szomszedja van, különben halott lesz. */
                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {
                /* Halott halott marad, ha három élő
                 szomszedja van, különben élő lesz. */
                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }
...
        ]]>
        </programlisting>        
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/davidhalasz/bhax/tree/master/attention_raising/Source/conway/c++">https://gitlab.com/davidhalasz/bhax/tree/master/attention_raising/Source/conway/c++</link>               
        </para>
        <para>
            A program felépítése nagyon hasonlít a Mandelbrot nagyítós fejezetnél megismert programhoz, és a futtatása is ugyanúgy történik (qmake és make parancsok használata). Itt is 5 külöálló fájlból fog állni a programunk.
            A main.cpp-ben adjuk meg, hogy mekkora legyen az ablakunk mérete. Jelen esetünkben 100x75 pixel méretű lesz. <function>w.show()</function> függvénnyel hívjuk elő a az ablakot.
        </para>
        <programlisting language="c++"><![CDATA[
            #include <QApplication>
            #include "sejtablak.h"
            #include <QDesktopWidget>

            int main(int argc, char *argv[])
            {
              QApplication a(argc, argv);
              SejtAblak w(100, 75);
              w.show();
              
              return a.exec();
            }
            ]]>
        </programlisting> 
        <para>
           A <function>sejtablak.h</function> fájlban megadjuk az ablakon belüli rácsokat, melynek mérete megegyezik a az ablakunk méretével. Továbbá az ELO és HALOTT boolean típusú változónk konstans változók lesznek, azaz 
           ezt a későbbiekben a programon belül ezek értékeit nem fogjuk tudni megváltozatni. A protected-en belül pedig további változókat dekralálunk.
        </para> 
        <programlisting language="c++"><![CDATA[
            #ifndef SEJTABLAK_H
            #define SEJTABLAK_H

            #include <QMainWindow>
            #include <QPainter>
            #include "sejtszal.h"

            class SejtSzal;

            class SejtAblak : public QMainWindow
            {
              Q_OBJECT
              
            public:
              SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);

              ~SejtAblak();
              static const bool ELO = true;
              static const bool HALOTT = false;
              void vissza(int racsIndex);
              
            protected:
              bool ***racsok;
              bool **racs;
              int racsIndex;
              int cellaSzelesseg;
              int cellaMagassag;
              int szelesseg;
              int magassag;    
              void paintEvent(QPaintEvent*);
              void siklo(bool **racs, int x, int y);
              void sikloKilovo(bool **racs, int x, int y);
              
            private:
              SejtSzal* eletjatek;
              
            };

            #endif // SEJTABLAK_H
            ]]>
        </programlisting> 
        <para>
            sejtszal.h
        </para>
        <programlisting language="c++"><![CDATA[
            #ifndef SEJTSZAL_H
            #define SEJTSZAL_H

            #include <QThread>
            #include "sejtablak.h"

            class SejtAblak;

            class SejtSzal : public QThread
            {
                Q_OBJECT

            public:
                SejtSzal(bool ***racsok, int szelesseg, int magassag,
                         int varakozas, SejtAblak *sejtAblak);
                ~SejtSzal();
                void run();

            protected:
                bool ***racsok;
                int szelesseg, magassag;
                int racsIndex;
                int varakozas;
                void idoFejlodes();
                int szomszedokSzama(bool **racs,
                                    int sor, int oszlop, bool allapot);
                SejtAblak* sejtAblak;

            };

            #endif // SEJTSZAL_H
            ]]>
        </programlisting>
        <para>
            A <function>sejtablak.cpp</function> fájlban a SejtAblak() függvénnyel az ablakkal kapcsolatos adatokat adjuk meg. Ez 3 paramétert vár: szélesség, magasság és egy pointert, ami a QWidget "parent" paraméteréhez tartozik. Ennek értéke 0. A <function>setWindowTitle()</function> azt jelenti, hogy a zárójelben megadott szöveg lesz majd az ablakunk fejlécében látható cím. A <function>setFixedSize()</function>-ban a szélességet és a magasságot megszorozzuk 6-al, majd ez alapján for ciklusokkal létrehozunk két rácsot. A <function>paintEvent</function>-en belül végiglépkedunk a sorokon és az oszlopokon és ha az adott cellában 
            van egy ELO,  akkor feketére színezzük a QT segítségével. Ellenkező esetben fehér lesz. 
        </para>
        <programlisting language="c++"><![CDATA[
#include "sejtablak.h"

SejtAblak::SejtAblak(int szelesseg, int magassag, QWidget *parent)
: QMainWindow(parent)
{
  setWindowTitle("A John Horton Conway-féle életjáték");
  
  this->magassag = magassag;
  this->szelesseg = szelesseg;

  
  cellaSzelesseg = 6;
  cellaMagassag = 6;

  setFixedSize(QSize(szelesseg*cellaSzelesseg, magassag*cellaMagassag));
  
  racsok = new bool**[2];
  racsok[0] = new bool*[magassag];
  for(int i=0; i<magassag; ++i)
    racsok[0][i] = new bool [szelesseg];
  racsok[1] = new bool*[magassag];
  for(int i=0; i<magassag; ++i)
    racsok[1][i] = new bool [szelesseg];

  racsIndex = 0;
  racs = racsok[racsIndex];

  for(int i=0; i<magassag; ++i)
    for(int j=0; j<szelesseg; ++j)
      racs[i][j] = HALOTT;

    sikloKilovo(racs, 5, 60);

  eletjatek = new SejtSzal(racsok, szelesseg, magassag, 120, this);

  eletjatek->start();
  
}

void SejtAblak::paintEvent(QPaintEvent*) {
  QPainter qpainter(this);
  
  bool **racs = racsok[racsIndex];
  for(int i=0; i<magassag; ++i) { 
    for(int j=0; j<szelesseg; ++j) {
      if(racs[i][j] == ELO)
    qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
              cellaSzelesseg, cellaMagassag, Qt::black);
    else
      qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                cellaSzelesseg, cellaMagassag, Qt::white);
      qpainter.setPen(QPen(Qt::gray, 1));
    
    qpainter.drawRect(j*cellaSzelesseg, i*cellaMagassag,
              cellaSzelesseg, cellaMagassag);
    }
  }
  qpainter.end();
}


SejtAblak::~SejtAblak()
{
  delete eletjatek;
  
  for(int i=0; i<magassag; ++i) {
    delete[] racsok[0][i];
    delete[] racsok[1][i];
  }
  
  delete[] racsok[0];
  delete[] racsok[1];
  delete[] racsok;
  
  
}

void SejtAblak::vissza(int racsIndex)
{
  this->racsIndex = racsIndex;
  update();
}

void SejtAblak::siklo(bool **racs, int x, int y) {
  
  racs[y+ 0][x+ 2] = ELO;
  racs[y+ 1][x+ 1] = ELO;
  racs[y+ 2][x+ 1] = ELO;
  racs[y+ 2][x+ 2] = ELO;
  racs[y+ 2][x+ 3] = ELO;
  
}

void SejtAblak::sikloKilovo(bool **racs, int x, int y) {
  
  racs[y+ 6][x+ 0] = ELO;
  racs[y+ 6][x+ 1] = ELO;
  racs[y+ 7][x+ 0] = ELO;
  racs[y+ 7][x+ 1] = ELO;
  
  ...
}
            ]]>
        </programlisting> 
        <para>
            Most nézzük meg a <function>sejtszal.cpp</function> fájlt. Itt fogjuk megszámolni a szomszédokat, és megadjuk a szomszédok száma alapján, hogy hol lesz élő és halott cella. Ennek a felépítése megegyezik a java programunkban ismertetett módszerrel. 
        </para>
        <programlisting language="c++"><![CDATA[
#include "sejtszal.h"

SejtSzal::SejtSzal(bool ***racsok, int szelesseg, int magassag, int varakozas, SejtAblak *sejtAblak)
{
    this->racsok = racsok;
    this->szelesseg = szelesseg;
    this->magassag = magassag;
    this->varakozas = varakozas;
    this->sejtAblak = sejtAblak;

    racsIndex = 0;
}

int SejtSzal::szomszedokSzama(bool **racs,
                              int sor, int oszlop, bool allapot) {
    int allapotuSzomszed = 0;
    for(int i=-1; i<2; ++i)
        for(int j=-1; j<2; ++j)
        
            if(!((i==0) && (j==0))) {
       
                int o = oszlop + j;
                if(o < 0)
                    o = szelesseg-1;
                else if(o >= szelesseg)
                    o = 0;

                int s = sor + i;
                if(s < 0)
                    s = magassag-1;
                else if(s >= magassag)
                    s = 0;

                if(racs[s][o] == allapot)
                    ++allapotuSzomszed;
            }
    return allapotuSzomszed;
}

void SejtSzal::idoFejlodes() {

    bool **racsElotte = racsok[racsIndex];
    bool **racsUtana = racsok[(racsIndex+1)%2];

    for(int i=0; i<magassag; ++i) { // sorok
        for(int j=0; j<szelesseg; ++j) { // oszlopok

            int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);

            if(racsElotte[i][j] == SejtAblak::ELO) {

                if(elok==2 || elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }  else {
               
                if(elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
        }
    }
    racsIndex = (racsIndex+1)%2;
}

void SejtSzal::run()
{
    while(true) {
        QThread::msleep(varakozas);
        idoFejlodes();
        sejtAblak->vissza(racsIndex);
    }
}

SejtSzal::~SejtSzal()
{
}
        ]]>
    </programlisting>
    <para>
        A program futtatása a következő: a <function>qmake -project</function> létrehoz egy .pro végződésű fájlt, amibe bele kell írni, hogy <function>QT += widgets</function>. Majd a parancssorba beírjuk hogy <function>qmake *.pro</function>, ami létrehoz egy Makefile-t. <function>make</function> parancssal bináris fájlt hozunk létre, majd futtatjuk a szoksásos g++ programot. Ha mindent jól csináltunk, a következő képernyőt kell kapnunk:
    </para>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/gt.png" width="60%" format="PNG"/>
        </imageobject>
    </mediaobject>        
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/davidhalasz/bhax/tree/master/attention_raising/Source/conway/brainb">https://gitlab.com/davidhalasz/bhax/tree/master/attention_raising/Source/conway/brainb</link>               
        </para>
        <para>
            A BrainB is egy Qt-s alkalmazás, ami OpenCV könyvtárt használ. A program célja a kiemelkedő e-sportolók korai felismerése illetve felkutatása, mérési módszerek alkalmazásával. A program lényege, hogy először egy doboz jelenik meg a képernyőn, középen egy kék körrel, ha az egeret minél tovább tartjuk a körön, annál több doboz jelenik meg a képernyőn és egyre gyorsabban is mozognak, egyre nehezbb lesz majd a körön tartani az egérmutatót.
            Most vizsgáljuk  meg a mérés alapötletét, ami a <function>BrainBWin.cpp</function> fájlban tallható, azon belül a <function>BrainBWin::updateHeroes</function> függvényben. Először is kiszámítjuk az egér és a Samu Entropy doboza (karakter) közötti távolságot, ennek eredményét a dist változóban tároljuk el.
            Ezután megnézzük, hogy a távolság (dist) nagyobb-e, mint 121 pixel, ha az if feltétel teljesül, akkor a <function>nofLost</function> értékét megnöveljük eggyel. Ha a nofLost értéke több lesz, mint 12, azaz 12*100 milliszekundum, akkor a feltétel teljesül, mert a játékos sikeresen tudta tartani több mint 1200 ms-on keresztül az adott karakteren az egérmutatót. Ekkor elmentjuk az adatokat a found2lost verembe, aminek értéke bit per second (bps) lesz.
            Ha az user nem képes 1200ms-on keresztül tartani, akkor az else ágba lépünk, tehát a a játékos elvesztette a karaktert és ennek adatát is elmentjük
            a <function>lost2found</function> változóba.

        </para>
        <programlisting language="c++"><![CDATA[
            void BrainBWin::updateHeroes ( const QImage &image, const int &x, const int &y )
{

        if ( start && !brainBThread->get_paused() ) {
                int dist = ( this->mouse_x - x ) * ( this->mouse_x - x ) + ( this->mouse_y - y ) * ( this->mouse_y - y );
                if ( dist > 121 ) {
                        ++nofLost;
                        nofFound = 0;
                        
                        if ( nofLost > 12 ) {
                                if ( state == found && firstLost ) {
                                    found2lost.push_back ( brainBThread->get_bps() );
                                }
                                firstLost = true;

                                state = lost;
                                nofLost = 0;
                                brainBThread->decComp();
                        }
                } else {
                        ++nofFound;
                        nofLost = 0;
                        if ( nofFound > 12 ) {

                                if ( state == lost && firstLost ) {
                                        lost2found.push_back ( brainBThread->get_bps() );
                                }
                                state = found;
                                nofFound = 0;
                                brainBThread->incComp();
                        }
                }
        }
        pixmap = QPixmap::fromImage ( image );
        update();
}
            ]]>
        </programlisting>
        <para>
            A fenti két számítást utána összeadjuk, elosztjuk 2-vel, majd 8-cal, végül pedig 1024-el osztjuk el és elmentjük egy text fájlba. Ez 
            a <function>BrainBWin.h</function> fájlban van felépítve. Ebből most számunkra az <function>int m1</function>, <function>int m2</function> és a <function>double res</function> változók az érdekesek. az integer típusú változók értékei a <function>lost2found</function> illetve a <function>found2lost</function> átlagával lesz egyenlő, ennek kiszámításához használjuk a <function>mean()</function> függvényt. A <function>res</function> változóba mentjük el a fentebb leírt képlettel kiszámított adatokat.
        </para>
        <programlisting language="c++"><![CDATA[
            textStremam <<  "\n";
            int m1 = m = mean ( lost2found );
            textStremam << "mean      : " <<  m << "\n";
            textStremam << "var       : " <<  var ( lost2found, m ) << "\n";

            textStremam << "found2lost: "  ;
            for ( int n : found2lost ) {
                textStremam << n << ' ';
            }
            textStremam <<  "\n";
            int m2 = m = mean ( found2lost );
            textStremam << "mean      : " <<  m << "\n";
            textStremam << "var       : " <<  var ( found2lost, m ) << "\n";

            if ( m1 < m2 ) {
                textStremam << "mean(lost2found) < mean(found2lost)" << "\n";
            }

            int min, sec;
            millis2minsec ( t, min, sec );
            textStremam << "time      : " <<  min  << ":"  << sec << "\n";

            double res = ( ( ( ( double ) m1+ ( double ) m2 ) /2.0 ) /8.0 ) /1024.0;
            textStremam << "U R about " << res << " Kilobytes\n";
            ]]>
        </programlisting>
        <para>
            A program futtatása után, ha az egeret képesek leszünk tartani egy adott kék ponton több, mint 1,2 másodpercig, akkor a program folyamatosan új
            dobozokat jelenít meg, és egyre gyorsabban is mozognak: 
        </para>
        <mediaobject>
              <imageobject>
                <imagedata fileref="img/brainb.png" width="60%" format="PNG"/>
              </imageobject>
        </mediaobject>
        <para>
            Ezeknek a dobozoknak a létrehozása és mozgatása a BrainBThread.cpp és a BrainBThread.h fájlokban vannak implementálva. A BrainThread.cpp-ban a a konstruktornak átadjuk paraméterként a szélességet és a magasságot. Itt a Hero lesz a karakter, azaz jelen esetünkben 5 karakter van megadva, ezek fognak tehát majd megjelenni először a képernyőn. Ezeket a <function>heroes</function> nevű verembe pakoljuk be a <function>push.back()</function> függvénnyel, melynek paraméterként adjuk át az általunk kreált Hero-k neveit egyenként. 
        </para>
        <programlisting language="c++"><![CDATA[
BrainBThread::BrainBThread ( int w, int h )
{
        dispShift = heroRectSize+heroRectSize/2;

        this->w = w - 3 * heroRectSize;
        this->h = h - 3 * heroRectSize;

        std::srand ( std::time ( 0 ) );

        Hero me ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                  this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 9 );

        Hero other1 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Norbi Entropy" );
        Hero other2 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 3, "Greta Entropy" );
        Hero other4 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Nandi Entropy" );
        Hero other5 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 7, "Matyi Entropy" );

        heroes.push_back ( me );
        heroes.push_back ( other1 );
        heroes.push_back ( other2 );
        heroes.push_back ( other4 );
        heroes.push_back ( other5 );
}
            ]]>
        </programlisting>
        <para>
            A dobozok mozgatásának kiszámítása a <function>BrainbThread.h</function> fájlban van megadva. 
        </para> 
        <programlisting language="c++"><![CDATA[
    void move ( int maxx, int maxy, int env ) {

        int newx = x+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 ) ;
        if ( newx-env > 0 && newx+env < maxx ) {
            x = newx;
        }
        int newy = y+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 );
        if ( newy-env > 0 && newy+env < maxy ) {
            y = newy;
        }

    }
    ]]>
        </programlisting>           
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
